rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 2)
View(df_sample)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 0)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 0)
n=5
rf_annualper = .18
rf_dailyper = rf_annualper/365
rf_periodper = n * rf_annualper/365
roll_RSR = function(x, y, width=5, risk_free_annual_per=0) {
## This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 0)
View(df_sample)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 0.18)
View(df_sample)
roll_RSR = function(x, y, width=5, risk_free_annual_per=0.0) {
## This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 0.18)
View(df_sample)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 2)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 2)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 0)
df_sample$RSR2 = roll_RSR(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 10)
View(df_sample)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
df_sample$RSR2 = roll_reg_sharpe(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 10)
View(df_sample)
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (n-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (n-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
df_sample$RSR2 = roll_reg_sharpe(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 10)
View(df_sample)
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (n-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
## Test data
## n = 5
## date_index = c(1,2,3,4,5)
## stock_y = c(5, 10, 6, 8, 14)
## df_sample = data.frame(date_index, stock_y)
## df_sample$LRRR = roll_LRRR(x=date_index, Y = stock_y, width=5)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
df_sample$RSR2 = roll_reg_sharpe(x = df_sample$date_index, y = df_sample$stock_y, width = 5, risk_free_annual_per = 10)
df_prices = c("DBC", "GLD", "VTI", "TLT", "^IRX") %>%
tq_get(get = "stock.prices", from = "2016-01-04", to = today())
df_prices <- df_prices %>%
select( -c(open, high, low, volume, adjusted)) %>%
spread(symbol, close) %>%
rename(IRX = '^IRX')
df_prices = na.omit(df_prices)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
df_prices = c("DBC", "GLD", "VTI", "TLT", "^IRX") %>%
tq_get(get = "stock.prices", from = "2016-01-04", to = today())
df_prices <- df_prices %>%
select( -c(open, high, low, volume, adjusted)) %>%
spread(symbol, close) %>%
rename(IRX = '^IRX')
df_prices = na.omit(df_prices)
library(roll)  # needed for roll_cov and roll_var functions
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (n-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
## Test data
## n = 5
## date_index = c(1,2,3,4,5)
## stock_y = c(5, 10, 6, 8, 14)
## df_sample = data.frame(date_index, stock_y)
## df_sample$LRRR = roll_LRRR(x=date_index, Y = stock_y, width=5)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
View(df_prices)
View(df_prices)
df_prices$date_index = as.numeric(difftime(df_prices$date, as.Date("2016-01-04")))
View(df_prices)
df_prices$date_index = as.numeric(difftime(df_prices$date, as.Date("2016-01-04")))
View(df_prices)
df_prices['index'] <- 1:length(df_prices$date)
View(df_prices)
df_prices$date$index = 1:length(df_prices$date)
df_prices$date_index = 1:length(df_prices$date)
View(df_prices)
df_prices = c("DBC", "GLD", "VTI", "TLT", "^IRX") %>%
tq_get(get = "stock.prices", from = "2016-01-04", to = today())
df_prices <- df_prices %>%
select( -c(open, high, low, volume, adjusted)) %>%
spread(symbol, close) %>%
rename(IRX = '^IRX')
df_prices = na.omit(df_prices)
# Create date index for x-axis for regression
df_prices$date_index = 1:length(df_prices$date)
View(df_prices)
# Equation from: https://stackoverflow.com/questions/66771929/intercept-and-slope-functions-in-r
library(roll)  # needed for roll_cov and roll_var functions
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (n-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
## Test data
## n = 5
## date_index = c(1,2,3,4,5)
## stock_y = c(5, 10, 6, 8, 14)
## df_sample = data.frame(date_index, stock_y)
## df_sample$LRRR = roll_LRRR(x=date_index, Y = stock_y, width=5)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
View(df_prices)
df_prices$RSR_VTI = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, risk_free_annual_per = 0)
df_prices$RSR_VTI = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width = 25, risk_free_annual_per = 0)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, x=df_prices$date_index, y = df_prices$VTI, width = 25)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 25)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 26)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 25)
str(df_prices)
# Create date index for x-axis for regression
df_prices$date_index = as.numeric(1:length(df_prices$date))
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 25)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 24)
x = df_prices$date_index
y =df_prices$VTI
width = 25
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (n-1)*slope
final = initial + (width-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 25)
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
#    x = df_prices$date_index
#    y =df_prices$VTI
#    width = 25
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (width-1)*slope
LRRR = 100 * (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 25)
df_prices$RSR_VTI = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width = 25, risk_free_annual_per = 0)
View(df_prices)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 200)
View(df_prices)
df_prices$RSR_VTI = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width = 200, risk_free_annual_per = 0)
View(df_prices)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$VTI, width = 200)
df_prices$RSR_VTI = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width = 200, risk_free_annual_per = 0)
View(df_prices)
width = 200
y = df_prices$VTI
df_prices$denom = (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
View(df_prices)
df_prices$test = df_prices$LRRR_test / df_prices$denom
View(df_prices)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=5) - rf_periodperc) / (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE, min_obs=4))
return(roll_RSR)
}
df_prices$RSR_VTI = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width = 200, risk_free_annual_per = 0)
View(df_prices)
df_prices$denom = (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE))
df_prices$test = df_prices$LRRR_test / df_prices$denom
View(df_prices)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$GLD, width = 200)
y = df_prices$GLD
df_prices$denom = (sqrt(width) * roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE))
df_prices$test = df_prices$LRRR_test / df_prices$denom
View(df_prices)
View(df_prices)
df_prices$denom = (sqrt(width)
* roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE))
View(df_prices)
df_prices$denom = (sqrt(width)
df_prices$denom = (sqrt(width) )
df_prices$denom = sqrt(width)
View(df_prices)
df_prices$denom =  roll::roll_sd(x=ROC(y, n=1, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE)
View(df_prices)
df_prices$SR = SharpeRatio(df_prices$GLD)
width = 200
y = df_prices$GLD
df_prices$denom =  roll::roll_sd(x=ROC(y, n=width, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE)
df_prices$denom = sqrt( roll::roll_var(x=ROC(y, n=width, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE))
View(df_prices)
df_prices$LRRR_test = roll_LRRR(x=df_prices$date_index, y = df_prices$GLD, width = 200) / 100
df_prices$denom = sqrt( roll::roll_var(x=ROC(y, n=width, type = "discrete", na.pad = TRUE), width=width, complete_obs = TRUE))
df_prices$test = df_prices$LRRR_test / df_prices$denom
View(df_prices)
df_prices$LRRR_returns = roll_LRRR(x=df_prices$date_index, y = df_prices$GLD, width = 200) / 100
View(df_prices)
df_prices$LRRR_returns = roll_LRRR(x=df_prices$date_index, y = df_prices$GLD, width = 250) / 100
options(digits = 4)
options(scipen=999)
df_prices$LRRR_returns = roll_LRRR(x=df_prices$date_index, y = df_prices$GLD, width = 250) / 100
View(df_prices)
df_prices$var_returns = roll_var(x = df_prices$LRRR_returns, width = 250)
df_prices$var_returns = roll::roll_var(x = df_prices$LRRR_returns, width = 250)
View(df_prices)
df_prices$var_returns = sqrt(roll::roll_var(x = df_prices$LRRR_returns, width = 250))
View(df_prices)
df_prices$Sharpe = df_prices$LRRR_returns / df_prices$var_returns
View(df_prices)
```{r Define LRRR Linear Rate of Return Function, , warning=FALSE, message=FALSE, echo=FALSE}
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (width-1)*slope
LRRR = (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
f_prices$LRRR_returns = roll_LRRR(x=df_prices$date_index, y = df_prices$GLD, width = 250)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=width) - rf_periodperc) / sqrt(roll::roll_var(x = (roll_LRRR(x, y, width=width) - rf_periodperc), width = width))
return(roll_RSR)
}
df_prices$roll_sharpe = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=250)
View(df_prices)
df_prices$roll_sharpe = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=250)
View(df_prices)
options(digits = 4)
options(scipen=999)
df_prices = c("DBC", "GLD", "VTI", "TLT", "^IRX") %>%
tq_get(get = "stock.prices", from = "2016-01-04", to = today())
df_prices <- df_prices %>%
select( -c(open, high, low, volume, adjusted)) %>%
spread(symbol, close) %>%
rename(IRX = '^IRX')
df_prices = na.omit(df_prices)
# Create date index for x-axis for regression
df_prices$date_index = as.numeric(1:length(df_prices$date))
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
# Equation from: https://stackoverflow.com/questions/66771929/intercept-and-slope-functions-in-r
library(roll)  # needed for roll_cov and roll_var functions
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (width-1)*slope
LRRR = (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
## Test data
## n = 5
## date_index = c(1,2,3,4,5)
## stock_y = c(5, 10, 6, 8, 14)
## df_sample = data.frame(date_index, stock_y)
## df_sample$LRRR = roll_LRRR(x=date_index, Y = stock_y, width=5)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=width) - rf_periodperc) / sqrt(roll::roll_var(x = (roll_LRRR(x, y, width=width) - rf_periodperc), width = width))
return(roll_RSR)
}
df_prices$roll_sharpe = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=250)
View(df_prices)
df_prices$returns = roll_LRRR(x = df_prices$date_index, y = df_prices$GLD, width = 25)
df_prices$returns = roll_LRRR(x = df_prices$date_index, y = df_prices$GLD, width = 250)
df_prices$returns = roll_LRRR(x = df_prices$date_index, y = df_prices$GLD, width = 25)
View(df_prices)
df_prices$returns = roll_LRRR(x = df_prices$date_index, y = df_prices$GLD, width = 25)
View(df_prices)
df_prices$denom = sqrt(roll::roll_var(x = (roll_LRRR(x, y, width=25) - rf_periodperc), width = 25))
df_prices$denom = sqrt(roll::roll_var(x = (roll_LRRR(x = df_prices$date_index, y = df_prices$GLD,  width=25) - rf_periodperc), width = 25))
df_prices$denom = sqrt(roll::roll_var(x = (roll_LRRR(x = df_prices$returns,  width=25) - rf_periodperc), width = 25))
df_prices$denom = sqrt(roll::roll_var(x = (roll_LRRR(x = df_prices$date_index, y = df_prices$GLD, width = 25) - rf_periodperc), width = 25))
?roll_var
df_prices$denom = roll::roll_var(x = df_prices$returns, width = 25)
View(df_prices)
df_prices$roll_sharpe = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=25)
View(df_prices)
# Tidy libraries
# install.packages("devtools")
# devtools::install_github("business-science/tidyquant")
# install.packages("broom")
library(knitr)
library(tidyverse)
library(tidyr)
library(tidyquant)
library(tibble)
library(tibbletime)
library(lubridate)
library(TTR)
library(tidyquant)
library(broom)
library(corrr)
library(alfred)
library(RcppRoll)
library(Hmisc)
library(kableExtra)
library(huxtable)
library(pracma)
library(gridExtra)
library(xts)
library(scales)
library(directlabels)
library(ggthemes)
library(ggfortify)
library(zoo)  # used for rollmean
library(padr)
library(roll)
library(PerformanceAnalytics)
# Data acquisition libraries
library(Quandl)
library(quantmod)
library(fredr)  # Fred
library(imfr, warn.conflicts = FALSE, quietly=TRUE)  # IMF
library(gdata)
library(readxl)
library(rstudioapi)
library(openxlsx)
library(fpp2)  # Hyndman Forecast package
library(DataCombine)
# User defined functions
source("./chart_recession.R")  # for add_rec_shade recession shading function
# source("./signal_aggregation_functions.R")
# source("./financial_functions.R")
# source("./cycleanalytics.R")
options(digits = 4)
options(scipen=999)
df_prices = c("DBC", "GLD", "VTI", "TLT", "^IRX") %>%
tq_get(get = "stock.prices", from = "2016-01-04", to = today())
df_prices <- df_prices %>%
select( -c(open, high, low, volume, adjusted)) %>%
spread(symbol, close) %>%
rename(IRX = '^IRX')
df_prices = na.omit(df_prices)
# Create date index for x-axis for regression
df_prices$date_index = as.numeric(1:length(df_prices$date))
# Equation from: https://stackoverflow.com/questions/66771929/intercept-and-slope-functions-in-r
library(roll)  # needed for roll_cov and roll_var functions
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
roll_LRRR = function(x, y, width = 5) {  # x must be a date index = 1,2, ...
## Linear regression rate of return (LRRR)  (Stocks & Commodities V. 39:09 (16–23): Linear Regression Of Price And Time Part 1:
## Three Basic Tools by Mike B. Siroky, MD
library(roll)
roll_slope <- function(x, y, width) {roll_cov(x, y, width) / roll_var(x, width)  }
initial_time = (width-1) /2
y_mean = roll_mean(x = y, width)
slope = roll_slope(x = x, y, width)
initial = y_mean - slope * initial_time
final = initial + (width-1)*slope
LRRR = (final - initial) / initial  # LRRR is Linear Regression Rate of Return
return(LRRR)
}
## Test data
## n = 5
## date_index = c(1,2,3,4,5)
## stock_y = c(5, 10, 6, 8, 14)
## df_sample = data.frame(date_index, stock_y)
## df_sample$LRRR = roll_LRRR(x=date_index, Y = stock_y, width=5)
roll_reg_sharpe = function(x, y, width=5, risk_free_annual_per=0.0) {   # Risk free rate should be annual rate
## Regression Sharpe Ratio: This function computes the rolling Regression Sharpe Ratio which divides the rolling return given by the regression line by the scaled stad deviation to produce a Sharpe Ratio.
## This function requires the LRRR function which computes the Linear Regression Return Rate.
##  (Stocks & Commodities V. 40:03 (14–20): Linear Regression Of Price And Time Part 3 by Mike B. Siroky, MD)
## Note: The output requires 2 * width since the variance is over the returns which reuire the first width. The second width is the variance over the returns which means 2*width is required for the data.
library(roll)
rf_periodperc = width * risk_free_annual_per/365
roll_RSR = (roll_LRRR(x, y, width=width) - rf_periodperc) / sqrt(roll::roll_var(x = (roll_LRRR(x, y, width=width) - rf_periodperc), width = width))
return(roll_RSR)
}
df_prices$rsr_GLD  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=25)
View(df_prices)
df_prices$rsr_GLD  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=250)
df_prices$rsr_GLD  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=250)
View(df_prices)
df_prices$rsr_TLT  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$TLT, width=200)
df_prices$rsr_GLD  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=200)
View(df_prices)
df_prices$rsr_VTI  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width=200)
df_prices$rsr_DBC  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$DBC, width=200)
View(df_prices)
df_prices$rsr_GLD  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=50)
df_prices$rsr_TLT  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$TLT, width=50)
df_prices$rsr_VTI  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width=50)
df_prices$rsr_DBC  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$DBC, width=50)
View(df_prices)
df_prices$rsr_GLD  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$GLD, width=100)
df_prices$rsr_TLT  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$TLT, width=100)
df_prices$rsr_VTI  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$VTI, width=100)
df_prices$rsr_DBC  = roll_reg_sharpe(x=df_prices$date_index, y = df_prices$DBC, width=100)
View(df_prices)
